<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=0.5">

        <link href="/css/main.css" rel="stylesheet" type="text/css">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="shortcut icon" href="/image/Yc.jpg">
        <link href="/css/prism.css" rel="stylesheet" />
        <title>20181208</title>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-78070816-3"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            
            gtag('config', 'UA-78070816-3');
        </script>
    </head>
    <body>
        <!-- suppport block of mathjax -->
        <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <!-- support mathjax inline -->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                tex2jax: {inlineMath: [['$','$']]},
                messageStyle: "none"
            });
        </script>
        <script>
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)){
                document.body.classList.add('mobile');
            }
        </script>
        <script src="/js/prism.js"></script>
        <div class="inner">
            <h2>20181208</h2>

<p><strong>Overview:</strong></p>

<ul>
<li>Algorithm: <a href="https://leetcode-cn.com/problems/integer-to-roman/">整数转罗马数字</a></li>
<li>Review: <a href="https://medium.freecodecamp.org/understand-your-programs-memory-92431fa8c6b">How to understand your program's memory</a></li>
<li>Technique: 暂无</li>
<li>Share: 暂无</li>
</ul>

<h3>Algorithm: 整数转罗马数字</h3>

<h4>题目</h4>

<p>罗马数字包含以下七种字符：<code>I</code>，<code>V</code>，<code>X</code>，<code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>

<pre><code>字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
</code></pre>

<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X + II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX + V + II</code> 。</p>

<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>

<p><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。
<code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。
<code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>

<p>示例 1:</p>

<pre><code>输入: 3
输出: &quot;III&quot;
</code></pre>

<p>示例 2:</p>

<pre><code>输入: 4
输出: &quot;IV&quot;
</code></pre>

<p>示例 3:</p>

<pre><code>输入: 9
输出: &quot;IX&quot;
</code></pre>

<p>示例 4:</p>

<pre><code>输入: 58
输出: &quot;LVIII&quot;
解释: L = 50, V = 5, III = 3.
</code></pre>

<p>示例 5:</p>

<pre><code>输入: 1994
输出: &quot;MCMXCIV&quot;
解释: M = 1000, CM = 900, XC = 90, IV = 4.
</code></pre>

<h4>思路</h4>

<p>题目本身并不难，只需要将给定的数字中找出可以转换的最大值，然后减去这个值，继续循环即可。但对特别边界条件需要考虑一下。但因为限制了输入的范围为 1~3999，因此不用考虑超过 4000 的情况，同时也限定需要考虑的特殊情况只有 6 种。可将整数和对应罗马数字字符串的关系统一考虑，查表即可。</p>

<h4>测试用例及代码实现</h4>

<ul>
<li>代码请移步 <a href="https://github.com/SmartBrave/leetcode_sb/tree/master/12IntToRoman">Github</a></li>
</ul>

<h3>Review: How to understand your program's memory</h3>

<p>这篇文章从整体角度描述了一个进程的内存布局，尤其是堆和栈。并分析了堆栈的相关原理及可能出现的问题，最后给出了这些问题的解决办法。总体上比较简单，我做一下大体翻译：</p>

<p>作为一个 C/C++ 程序员，是需要和内存直接打交道的。经常会出现的错误就是 segfaults。就是访问一个已经被释放的内存，这块内存已经被你通过 <code>free</code> 释放掉了，或者被系统自动释放了，比如栈。</p>

<p>理解这些问题特别简单，而且也能帮你写出更好的程序。</p>

<h5>内存是如何分布的?</h5>

<p><img src="/images/MemoryDivided.jpg" weight="100%" height="100%"></p>

<p>内存被分为多个段，其中最重要的两个就是堆和栈。栈是线性读写的，而堆是随机的。</p>

<p>栈上保存了寄存器信息、函数调用信息、变量分配信息等。并且栈内存是由程序管理而非程序员。而堆通常被用来分配一块大内存来存放那些根据程序员意愿存在与否的数据，也就是说，控制堆内存的用法是程序员自己的事情。我们也称堆为动态内存。你可以使用 <code>malloc</code> 来分配内存，并且使用 <code>free</code> 释放。</p>

<h5>理解栈</h5>

<p>每个本地变量、函数调用都被存放到栈上。基于此，你可以做很多事情--大多数都是你不希望发生的--比如缓冲溢出和访问错误内存。</p>

<p>所以，栈是怎么工作的？</p>

<p>栈是一个先进后出的数据结构。你可以将其理解为一个装书的箱子--最先拿出来的书只能是最后装进去的。通过这种数据结构，程序可以很容易地使用 <code>push</code> 和 <code>pop</code> 管理自己的所有操作。这两个操作是相反的，<code>push</code> 操作插入数据到栈顶，而 <code>pop</code>从栈顶弹出数据；</p>

<p><img src="/images/PushAndPopOperations.jpg" weight="100%" height="100%"></p>

<p>为了记录当下的内存位置，有一个特殊的寄存器叫栈顶指针寄存器（Stack Pointer）。你需要保存数据时，向上移动栈顶指针寄存器并 push 数据，需要退出函数时，向下移动栈顶指针寄存器即可，很简单！</p>

<h5>理解堆</h5>

<p>和栈相反，当您希望某些东西存在一段时间而不依赖于函数和作用域时，就需要使用到堆。C 语言库 stdlib 提供了两个函数：<code>malloc</code> 和 <code>free</code>。<code>malloc</code> 向操作系统请求一块空间，并返回起始地址的指针。<code>free</code> 告诉系统我们请求的内存不再使用了，可以释放以供其他任务使用。</p>

<p>但随之而来的问题是：内存泄漏！</p>

<p>内存泄漏是我们申请了一块内存，在没有指针指向它之前，这块内存还没有被释放。这导致程序使用了过多的内存，超出了总共的可用内存。为了避免内存泄漏，每次我们不再需要堆内存的时候，记得释放它。</p>

<p>对堆内存的管理是必要的。但也需要注意如何使用。像栈一样，堆内存释放后也就不能再访问了。</p>

<h5>结构体和堆</h5>

<p>使用结构体时通常犯的一个错误是释放结构体。如果在结构体内分配了堆上的内存，我们需要首先释放，然后再释放实际的结构体。</p>

<h5>我是如何解决内存泄漏问题的</h5>

<p>我用 C 语言的大多数时候都在使用结构体。因此我总是强制使用两个函数：构造函数和析构函数来避免内存泄漏的问题。即在构造函数中申请空间，并在析构函数中释放空间，很容易解决了这个问题。</p>

<hr />

<p><em>ARTS project is a learning project initiated by <a href="https://coolshell.cn">Hao Chen</a>. A means learning a Algorithm on <a href="https://leetcode.com">LeetCode</a>,R means Reviewing an English article about programer,T means learning a Technique skill,and S means doing a Share with others that influence people. Adhere to every week at least one year!</em></p>

<blockquote>
<p>This article was posted on my <a href="https://sbrave.cn">blog</a> and <a href="https://github.com/SmartBrave/ARTS">Github</a> using the MIT Open Source License.</p>
</blockquote>

        </div>
    </body>
</html>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/haoel/anti-baidu@0.6.2/js/anti-baidu-latest.min.js" charset="UTF-8"></script>
