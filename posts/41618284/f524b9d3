<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=0.5">

        <link href="/css/main.css" rel="stylesheet" type="text/css">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="shortcut icon" href="/image/Yc.jpg">
        <link href="/css/prism.css" rel="stylesheet" />
        <title>20181124</title>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-78070816-3"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            
            gtag('config', 'UA-78070816-3');
        </script>
    </head>
    <body>
        <!-- suppport block of mathjax -->
        <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <!-- support mathjax inline -->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                tex2jax: {inlineMath: [['$','$']]},
                messageStyle: "none"
            });
        </script>
        <script>
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)){
                document.body.classList.add('mobile');
            }
        </script>
        <script src="/js/prism.js"></script>
        <div class="inner">
            <h2>20181124</h2>

<p>Overview:
* Algorithm: <a href="https://leetcode-cn.com/explore/interview/card/tencent/221/array-and-strings/899/">三数之和</a>
* Review: <a href="https://medium.freecodecamp.org/an-introduction-to-git-merge-and-rebase-what-they-are-and-how-to-use-them-131b863785f">An Introduction to Git Merge and Git Rebase: What They Do and When to Use Them</a>
* Technique: 一些有趣/提高效率的命令行工具
* Share: 视频压缩编码的基本原理</p>

<h3>Algorithm: 三数之和</h3>

<h4>题目</h4>

<p>给定一个包含 n 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>

<p>注意：答案中不可以包含重复的三元组。</p>

<pre><code>例如，给定数组 nums = [-1,0,1,2,-1,-4],

满足要求的三元组集合为：
[
    [-1,0,1],
    [-1,-1,2]
]
</code></pre>

<h4>思路</h4>

<p>这道题目暂时没想到更优的方法，只好先采用暴力寻找法了。关键的地方在于，a + b + c = 0，所以可以先找到两个数 a 和 b，就可以间接确定要寻找的 c 值。如果数组是排好序的，寻找 c 只需要 O($\lg n$) 的时间复杂度。但 a 和 b 的两层遍历，需要 O($n^2$) 时间复杂度。所以总体上算法的时间复杂度是 O($n^2\lg n$)。</p>

<h4>测试用例及代码实现</h4>

<ul>
<li>代码请移步 <a href="https://github.com/SmartBrave/leetcode_sb/tree/master/15ThreeSum">Github</a></li>
</ul>

<h3>Review: An Introduction to Git Merge and Git Rebase: What They Do and When to Use Them</h3>

<p>作为一名开发者，Git 是不可避免的版本控制工具。上一篇 ARTS 中分享了你不应该使用 rebase 的几个理由，但在这篇分享中，作者比较了 <code>git rebase</code> 和 <code>git merge</code> 的优势和劣势，说明了应该在什么情况下使用 rebase，在什么情况下使用 merge。以下是正文：</p>

<p>首先，Git Merge 和 Git Rebase 都是为了解决相同的问题--合并多个分支上的改变为一个分支。但它们的实现方式是完全不同的。</p>

<h4>Git Merge</h4>

<p>merge 总是会提交某些改变到其他的分支上去，即将源分支上的内容合并到目标分支上。在这个过程中，只有目标分支被改变，源分支历史保持不变。</p>

<p><img src="/images/MergeMasterToFeatureBranch.png" width="100%" height="100%"></p>

<h5>优势</h5>

<ul>
<li>简单、熟悉</li>
<li>保留完整的历史和时间序列</li>
<li>维护分支的上下文</li>
</ul>

<h5>劣势</h5>

<ul>
<li>太多的提交会污染提交历史</li>
<li>使用 <code>git bisect</code> 调试问题变得很困难</li>
</ul>

<h5>使用姿势</h5>

<p>合并 master 分支到 feature 分支上：</p>

<pre><code class="language-shell">$ git checkout feature
$ git merge master

(or)

$ git merge master feature
</code></pre>

<p>这样将在 feature 分支上创建一个新的「合并提交」，以保留两个分支的历史。</p>

<h4>Git Rebase</h4>

<p>rebase 是合并一个分支上改变到另一个分支的另一种方式。它会压缩所有的变化到一个 patch 中，然后将这个 patch 合并到目标分支上。</p>

<p>但和 merge 不同的是，rebase 会使得提交历史变得平坦，因为它将已完成的作业从一个分支转移到另一个分支。在这个过程中，不需要的历史记录被消除了。</p>

<p><img src="/images/RebaseFeatureBranchIntoMaster.png" width="100%" height="100%"></p>

<h5>优势</h5>

<ul>
<li>简化可能复杂的历史记录</li>
<li>操作单个提交很容易</li>
<li>避免在繁忙的仓库中使用繁忙的分支上使用 merge 时引入的「噪声」</li>
<li>通过将它们作为单个提交来清理中间提交，这对 DevOps 团队很有用</li>
</ul>

<h5>劣势</h5>

<ul>
<li>很隐藏上下文</li>
<li>当在一个团队工作时，对公共仓库进行操作会特别危险</li>
<li>使用 rebase 保持 feature 分支是最新的是个额外的工作</li>
<li>对远程分支操作时需要强制推送。很容易导致远程分支被改变</li>
</ul>

<h5>使用姿势</h5>

<p>rebase feature 分支到 master 分支上：</p>

<pre><code class="language-shell">$ git checkout feature
$ git rebase master
</code></pre>

<p>通过重写 feature 分支的每个 commit，就将 feature 分支移动到了 master 分支上。</p>

<h5>交互式的 rebase</h5>

<p>这种方式允许修改每个 commit 并将其移动到新分支上。相比自动化的方式，这样有时候更有用，因为它可以完整控制每个 commit 历史。一个典型的场景是在合并 feature 分支到 master 前先使用 rebase 来清理掉混乱的历史。</p>

<pre><code class="language-shell">$ git checkout feature
$ git rebase -i master
</code></pre>

<p>这将打开编辑器列出将要移动的所有 commit:</p>

<pre><code class="language-shell">pick 22d6d7c Commit message#1
pick 44e8a9b Commit message#2
pick 79f1d2h Commit message#3
</code></pre>

<p>这确定了 rebase 执行后这个分支应该具有的样子。通过重排这些序列，你可以使提交历史变成你想要的样子。比如可以使用 <code>fixup</code>，<code>squash</code>，<code>edit</code> 等代替 <code>pick</code>。</p>

<h4>该用哪一个？</h4>

<p>因为每个团队不一样，没法概括地说决定用哪个。但我们需要从某个地方开始。</p>

<p>决定用 rebase 或 merge 时，每个团队都需要考虑很多问题。因为事实证明，一种工作流程并不比另一种更好，这取决于您的团队。需要考虑整个团队的 rebase 和 git 能力水平，并且综合对可追溯性和合并历史的重视程度。来决定应该使用哪一种。并且需要在明确的分支策略的背景下考虑 merge 和 rebase。</p>

<h4>我的建议</h4>

<p>随着团队的增长，总是使用 merge 越来越难以管理开发中的改变。为了拥有一个干净的、可读性强的提交历史，使用 rebase  会更加有效。</p>

<p>通过考虑一下情况，您可以充分使用 rebase:</p>

<ul>
<li>你只在本地开发，而不会将代码提交到远程仓库共享。这时，你应该使用 rebase 而不是 merge。</li>
<li>你创建了一个 pull request，其他人正在 review 你的代码并且有可能将其拉取到它们的分支上查看。这时你不应该使用 rebase，你应该创建一个 commit 并且更新你的 feature 分支。这有助于跟踪 pull request 并且方式以外的破坏。</li>
<li>review 已完成，可以整合到目标分支中。鉴于其他开发人员从这一点开始不会在这些变化中进行合并，你可以使用 rebase  重写历史记录并折叠原始提交。</li>
</ul>

<h3>Technique</h3>

<p>这周偶然看到一篇文章，里面列出了很多实用的命令行工具，可以大大提高效率。其中有些是我已经在用的，有些是还不知道的；有些是对系统自带工具的增强，也有些是系统没有带的功能。分享给大家：</p>

<ul>
<li>ag：功能类似于 grep 或 ack，但搜索更快，结果展示更友好；</li>
<li>tig：git 的一个工具，可以很方便地查看 git commit 等；</li>
<li>htop：top 的增强版；</li>
<li>mycli：MySQL 客户端，提供命令提示、自动补全等功能；</li>
<li>jq：一个 json 工具；</li>
<li>shellcheck：从名字上就可以看出来，是一个 shell 脚本语法检查工具；</li>
<li>yapf：Python 代码格式规范化工具，Google 开发的。由于我不怎么写 Python，就没装；</li>
<li>tldr：被 man page 虐得死去活来？试试这个吧；</li>
<li>fzf：提供文件、历史命令搜索功能；</li>
<li>fpp：可以将命令行输出的文件名直接打开，试试<code>git status | fpp</code>；</li>
<li>axel：「我要代替 wget!」；</li>
<li>cloc：代码统计工具；</li>
<li>sz/rz：文件远程 copy，可以跳过跳板机；</li>
<li>ccache：大型项目编译的时间太长难以忍受？ccache 为您提供缓存，加快编译速度！</li>
<li>tmux：终端工具，我用 item2，所以没装；</li>
<li>neovim：声称要替代 vim，不知道现在怎么样了；</li>
<li>autojump：时间就是生命，而每次都逐个 <code>cd xx;ls xx;cd xx...</code>简直就是浪费生命；</li>
<li>fuck：想打<code>git status</code> 结果打成了 <code>git statua</code>？fuck 一下，你就知道。</li>
<li>fd: A simple, fast and user-friendly alternative to find.</li>
</ul>

<h3>Share: <a href="/posts/bdbfe742">视频压缩编码的基本原理</a></h3>

<p>Share 部分分享一个之前写的一个笔记，关于音视频压缩的原理。写的很简略，暂时也不修改了。这段时间也在持续学习音视频相关内容，后期统一整理。</p>

<hr />

<p><em>ARTS project is a learning project initiated by <a href="https://coolshell.cn">Hao Chen</a>. A means learning a Algorithm on <a href="https://leetcode.com">LeetCode</a>,R means Reviewing an English article about programer,T means learning a Technique skill,and S means doing a Share with others that influence people. Adhere to every week at least one year!</em></p>

<blockquote>
<p>This article was posted on my <a href="https://sbrave.cn//posts/41618284/f524b9d3">blog</a> and <a href="https://github.com/SmartBrave/ARTS">Github</a> using the MIT Open Source License.</p>
</blockquote>

        </div>
    </body>
</html>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/haoel/anti-baidu@0.6.2/js/anti-baidu-latest.min.js" charset="UTF-8"></script>
