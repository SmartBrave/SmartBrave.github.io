<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=0.5">

        <link href="/css/main.css" rel="stylesheet" type="text/css">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="shortcut icon" href="/image/Yc.jpg">
        <link href="/css/prism.css" rel="stylesheet" />
        <title>贪吃蛇源码</title>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-78070816-3"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            
            gtag('config', 'UA-78070816-3');
        </script>
    </head>
    <body>
        <!-- suppport block of mathjax -->
        <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <!-- support mathjax inline -->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                tex2jax: {inlineMath: [['$','$']]},
                messageStyle: "none"
            });
        </script>
        <script>
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)){
                document.body.classList.add('mobile');
            }
        </script>
        <script src="/js/prism.js"></script>
        <div class="inner">
            <h2>贪吃蛇源码</h2>

<p>这个贪吃蛇和<a href="/posts/509e7497">俄罗斯方块</a>当时一块写的，纯兴趣使然。完成之后自我感觉蛮好。我想，这就是让我在开始踏上编程之路时坚持的动力吧！</p>

<p><img src="/images/snake.jpg" width="100%" height="100%"></p>

<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;conio.h&gt;
#include &lt;windows.h&gt;
using namespace std;

#define MAXLEN 24
int score=0;

struct snake{
	//static int length;
	int x;
	int y;
	struct snake *p;
}*psn,*head;

struct Food
{
	int x,y;
}*pfo;

void gotoxy(int x,int y)
{
	COORD pos;
	pos.X=x*2;
	pos.Y=y;
	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE),pos);
}

void color(int a)//颜色函数
{
	SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE),a);
}

/*******初始化蛇******/

void creatsnake()
{
	psn=(struct snake*)malloc(sizeof(struct snake));
	head=psn;
	psn-&gt;x=3;
	psn-&gt;y=MAXLEN/2;
	//psn-&gt;length=1;
	psn-&gt;p=NULL;
	gotoxy(psn-&gt;x,psn-&gt;y);
	color(0x0A);
	cout&lt;&lt;&quot;●&quot;&lt;&lt;endl;

	struct snake* ps=(struct snake*)malloc(sizeof(struct snake));
	ps=(struct snake*)malloc(sizeof(struct snake));
	ps-&gt;x=2;
	ps-&gt;y=MAXLEN/2;
	ps-&gt;p=NULL;
	gotoxy(ps-&gt;x,ps-&gt;y);
	cout&lt;&lt;&quot;●&quot;&lt;&lt;endl;
	psn-&gt;p=ps;

	struct snake* ps1=(struct snake*)malloc(sizeof(struct snake));
	ps1=(struct snake*)malloc(sizeof(struct snake));
	ps1-&gt;x=1;
	ps1-&gt;y=MAXLEN/2;
	ps1-&gt;p=NULL;
	gotoxy(ps1-&gt;x,ps1-&gt;y);
	cout&lt;&lt;&quot;●&quot;&lt;&lt;endl;
	gotoxy(0,MAXLEN);
	color(0x07);
	ps-&gt;p=ps1;
}

/********初始化食物界面*********/

void creatfood(struct snake *p)		//食物不能在蛇的身体内部出现
{
	struct snake *tmp;
	srand(time(NULL));
	pfo=(struct Food*)malloc(sizeof(struct Food));
lab:	
	tmp=p;
	pfo-&gt;x=rand()%(MAXLEN-2)+1;
	pfo-&gt;y=rand()%(MAXLEN-2)+1;
	for (;tmp-&gt;p!=NULL;tmp=tmp-&gt;p)		//保证食物不会出现在蛇身体上
	{
		if(tmp-&gt;x==pfo-&gt;x&amp;&amp;tmp-&gt;y==pfo-&gt;y)
		{
			goto lab;
		}
	}

	gotoxy(pfo-&gt;x,pfo-&gt;y);
	color(0x0A);
	cout&lt;&lt;&quot;★&quot;&lt;&lt;endl;
	gotoxy(0,MAXLEN);
	color(0x07);
}

int IsEat(struct snake *p,struct Food *fo)
{
	if (p-&gt;x==fo-&gt;x&amp;&amp;p-&gt;y==fo-&gt;y)
	{
		return 1;
	}
	else
		return 0;
}

int IsAlive(struct snake *p)
{
	struct snake *tmp=p;
	if (p-&gt;x==0||p-&gt;x==(MAXLEN-1)||p-&gt;y==0||p-&gt;y==(MAXLEN-1))		//撞墙死亡
	{
		return 0;
	}
	else
		for (tmp=tmp-&gt;p;tmp-&gt;p!=NULL;tmp=tmp-&gt;p)					//撞到自己身体死亡
		{
			if(tmp-&gt;x==p-&gt;x&amp;&amp;tmp-&gt;y==p-&gt;y)
			{
				return 0;
			}
		}
		return 1;
}

void showscore()
{
	gotoxy(25,5);
	color(0x0A);
	cout&lt;&lt;&quot;成绩:&quot;&lt;&lt;score;
	gotoxy(0,MAXLEN);
}

void inter()
{
	int i,j;
	for (i=1;i&lt;=MAXLEN;i++)
	{
		for (j=1;j&lt;=MAXLEN;j++)
		{
			if ((i==1)||i==MAXLEN||(j==1)||j==MAXLEN)
			{
				//a[i][j]=1;
				cout&lt;&lt;&quot;■&quot;;
			}
			else
				cout&lt;&lt;&quot;  &quot;;
				//cout&lt;&lt;&quot;□&quot;;
				//a[i][j]=0;
		}
		cout&lt;&lt;endl;
	}
	creatsnake();
	creatfood(head);

	gotoxy(MAXLEN+2,3);
	color(0x0e);
	printf(&quot;按0自动行走或解除暂停&quot;);
	gotoxy(MAXLEN+3,4);
	printf(&quot;按上下左右控制方向&quot;);
	gotoxy(MAXLEN+4,5);
	printf(&quot;按其他任意键暂停&quot;);
	gotoxy(MAXLEN+6,MAXLEN/4+1);
	printf(&quot;score:%d&quot;,score);
	//cout&lt;&lt;&quot;score:&quot;&lt;&lt;score;		//为什么cout在此无法输出?
/*
	gotoxy(MAXLEN+2,MAXLEN/4+5);
	printf(&quot;按数字1—9选择难度等级&quot;);*/
	gotoxy(0,MAXLEN);
	color(0x07);

}

void swap(int *a,int *b)
{
	int tmp=*a;
	*a=*b;
	*b=tmp;
}

void up()
{	
	int frontx,fronty,laterx,latery;
	frontx=psn-&gt;x;
	fronty=psn-&gt;y-1;
	for(;psn-&gt;p!=NULL;psn=psn-&gt;p)		//bug:少循环了一次
	{
		laterx=psn-&gt;x;
		latery=psn-&gt;y;
		psn-&gt;x=frontx;
		psn-&gt;y=fronty;
		swap(&amp;laterx,&amp;frontx);
		swap(&amp;latery,&amp;fronty);
		gotoxy(psn-&gt;x,psn-&gt;y);
		color(0x0A);
		cout&lt;&lt;&quot;●&quot;&lt;&lt;endl;
	}
	{
		laterx=psn-&gt;x;
		latery=psn-&gt;y;
		psn-&gt;x=frontx;
		psn-&gt;y=fronty;
		swap(&amp;laterx,&amp;frontx);
		swap(&amp;latery,&amp;fronty);
		gotoxy(psn-&gt;x,psn-&gt;y);
		color(0x0A);
		cout&lt;&lt;&quot;●&quot;&lt;&lt;endl;
	}
	if (IsEat(head,pfo))
	{
		struct snake *tmp=(struct snake*)malloc(sizeof(struct snake));
		psn-&gt;p=tmp;
		tmp-&gt;x=frontx;
		tmp-&gt;y=fronty;
		tmp-&gt;p=NULL;
		//free tmp;
	}
	else if (psn-&gt;p==NULL)
	{
		gotoxy(frontx,fronty);
		color(0x07);
		cout&lt;&lt;&quot;  &quot;&lt;&lt;endl;
		//cout&lt;&lt;&quot;&quot;&lt;&lt;endl;
	}
	psn=head;
	gotoxy(0,MAXLEN);
}

void down()
{
	int frontx,fronty,laterx,latery;
	frontx=psn-&gt;x;
	fronty=psn-&gt;y+1;
	for(;psn-&gt;p!=NULL;psn=psn-&gt;p)		//bug:少循环了一次
	{
		laterx=psn-&gt;x;
		latery=psn-&gt;y;
		psn-&gt;x=frontx;
		psn-&gt;y=fronty;
		swap(&amp;laterx,&amp;frontx);
		swap(&amp;latery,&amp;fronty);
		gotoxy(psn-&gt;x,psn-&gt;y);
		color(0x0A);
		cout&lt;&lt;&quot;●&quot;&lt;&lt;endl;
	}
	{
		laterx=psn-&gt;x;
		latery=psn-&gt;y;
		psn-&gt;x=frontx;
		psn-&gt;y=fronty;
		swap(&amp;laterx,&amp;frontx);
		swap(&amp;latery,&amp;fronty);
		gotoxy(psn-&gt;x,psn-&gt;y);
		color(0x0A);
		cout&lt;&lt;&quot;●&quot;&lt;&lt;endl;
	}
	if (IsEat(head,pfo))
	{
		struct snake *tmp=(struct snake*)malloc(sizeof(struct snake));
		psn-&gt;p=tmp;
		tmp-&gt;x=frontx;
		tmp-&gt;y=fronty;
		tmp-&gt;p=NULL;
		//free tmp;
	}
	else if (psn-&gt;p==NULL)
	{
		gotoxy(frontx,fronty);
		color(0x07);
		cout&lt;&lt;&quot;  &quot;&lt;&lt;endl;
		//cout&lt;&lt;&quot;□&quot;&lt;&lt;endl;
	}
	psn=head;
	gotoxy(0,MAXLEN);
}

void left()
{	
	int frontx,fronty,laterx,latery;
	frontx=psn-&gt;x-1;
	fronty=psn-&gt;y;
	for(;psn-&gt;p!=NULL;psn=psn-&gt;p)		//bug:少循环了一次
	{
		laterx=psn-&gt;x;
		latery=psn-&gt;y;
		psn-&gt;x=frontx;
		psn-&gt;y=fronty;
		swap(&amp;laterx,&amp;frontx);
		swap(&amp;latery,&amp;fronty);
		gotoxy(psn-&gt;x,psn-&gt;y);
		color(0x0A);
		cout&lt;&lt;&quot;●&quot;&lt;&lt;endl;
	}
	{
		laterx=psn-&gt;x;
		latery=psn-&gt;y;
		psn-&gt;x=frontx;
		psn-&gt;y=fronty;
		swap(&amp;laterx,&amp;frontx);
		swap(&amp;latery,&amp;fronty);
		gotoxy(psn-&gt;x,psn-&gt;y);
		color(0x0A);
		cout&lt;&lt;&quot;●&quot;&lt;&lt;endl;
	}
	if (IsEat(head,pfo))
	{
		struct snake *tmp=(struct snake*)malloc(sizeof(struct snake));
		psn-&gt;p=tmp;
		tmp-&gt;x=frontx;
		tmp-&gt;y=fronty;
		tmp-&gt;p=NULL;
		//free tmp;
	}
	else if (psn-&gt;p==NULL)
	{
		gotoxy(frontx,fronty);
		color(0x07);
		cout&lt;&lt;&quot;  &quot;&lt;&lt;endl;
		//cout&lt;&lt;&quot;□&quot;&lt;&lt;endl;
	}
	psn=head;
		gotoxy(0,MAXLEN);
}

void right()
{
	int frontx,fronty,laterx,latery;
	frontx=psn-&gt;x+1;
	fronty=psn-&gt;y;
	for(;psn-&gt;p!=NULL;psn=psn-&gt;p)		//bug:少循环了一次
	{
		laterx=psn-&gt;x;
		latery=psn-&gt;y;
		psn-&gt;x=frontx;
		psn-&gt;y=fronty;
		swap(&amp;laterx,&amp;frontx);
		swap(&amp;latery,&amp;fronty);
		gotoxy(psn-&gt;x,psn-&gt;y);
		color(0x0A);
		cout&lt;&lt;&quot;●&quot;&lt;&lt;endl;
	}
	{
		laterx=psn-&gt;x;
		latery=psn-&gt;y;
		psn-&gt;x=frontx;
		psn-&gt;y=fronty;
		swap(&amp;laterx,&amp;frontx);
		swap(&amp;latery,&amp;fronty);
		gotoxy(psn-&gt;x,psn-&gt;y);
		color(0x0A);
		cout&lt;&lt;&quot;●&quot;&lt;&lt;endl;
	}
	if (IsEat(head,pfo))
	{
		struct snake *tmp=(struct snake*)malloc(sizeof(struct snake));
		psn-&gt;p=tmp;
		tmp-&gt;x=frontx;
		tmp-&gt;y=fronty;
		tmp-&gt;p=NULL;
		//free tmp;
	}
	else if (psn-&gt;p==NULL)
	{
		gotoxy(frontx,fronty);
		color(0x07);
		cout&lt;&lt;&quot;  &quot;&lt;&lt;endl;
		//cout&lt;&lt;&quot;□&quot;&lt;&lt;endl;
	}
	psn=head;
	gotoxy(0,MAXLEN);
}

void autoeat(struct snake *p,struct Food *pfo)		//蛇自动去吃食物 (递归)(迷宫问题)
{
/*
	Stack S;
	InitStack(&amp;S);*/
	struct snake* tmp=p-&gt;p;
	if (tmp-&gt;x==p-&gt;x&amp;&amp;tmp-&gt;y==p-&gt;y)
	{
		return;
	}
	if (p-&gt;x&lt;pfo-&gt;x)
	{
		right();
	}
	else
		if (p-&gt;x&gt;pfo-&gt;x)
		{
			left();
		}
		else
			if (p-&gt;y&lt;pfo-&gt;y)
			{
				down();
			}
			else
				if (p-&gt;y&gt;pfo-&gt;y)
				{
					up();
				}

/*
	struct snake* tmp=p-&gt;p;
	if (tmp-&gt;x==p-&gt;x&amp;&amp;tmp-&gt;y==p-&gt;y)
	{
		return;
	}
	if (p-&gt;x&lt;pfo-&gt;x)
	{
		right();
	}
	else
		if (p-&gt;x&gt;pfo-&gt;x)
		{
			left();
		}
	if (p-&gt;y&lt;pfo-&gt;y)
	{
		down();
	}
	else
		if (p-&gt;y&gt;pfo-&gt;y)
		{
			up();
		}*/

	//autoeat();
}

int main()
{
	system(&quot;cls&quot;);
	inter();
	gotoxy(0,24);
	int ch,tmp=0,v=1/*v：速度*/;
	//	v=getch();
	//	v=v-'0';
	while (true)
	{
		if(kbhit())
		{
			ch=getch();			//键盘方向键的键值是双字节的，所以要重复一次
			if(ch==224)
			{
				ch=getch();		
			}				
			if((tmp=='w'&amp;&amp;ch=='s')||(tmp=='s'&amp;&amp;ch=='w')||(tmp=='a'&amp;&amp;ch=='d')||(tmp=='d'&amp;&amp;ch=='a'))
			{
				ch=tmp;
			}
			tmp=ch;
		}
		switch (ch)
		{
		case '0':autoeat(head,pfo);break;
		case 72:up();break;
		case 80:down();break;
		case 75:left();break;
		case 77:right();break;
		default: break;
		}
		Sleep(300-score*2);
/*
		switch(v)
		{
		case 1:Sleep(400-score*1);break;
		case 2:Sleep(350-score*1);break;
		case 3:Sleep(300-score*1);break;
		case 4:Sleep(250-score*1);break;
		case 5:Sleep(200-score*1);break;
		case 6:Sleep(150-score*1);break;
		case 7:Sleep(100-score*1);break;
		case 8:Sleep(50*score*1);break;
		case 9:Sleep(1);break;
		default:break;
		}*/
		if (!IsAlive(head))
		{
			MessageBox(NULL,&quot;Game Over!&quot;,&quot;提示&quot;,MB_OK);
			break;
		}
		if(IsEat(head,pfo))
		{
			score+=3;
			creatfood(head);
			gotoxy(MAXLEN+6+3,MAXLEN/4+1);
			color(0x0A);
			printf(&quot;%d&quot;,score);
			gotoxy(0,MAXLEN);
			color(0x07);
		}

	}
	return 0;
}
</code></pre>

        </div>
    </body>
</html>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/haoel/anti-baidu@0.6.2/js/anti-baidu-latest.min.js" charset="UTF-8"></script>
