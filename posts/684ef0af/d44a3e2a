<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=0.5">

        <link href="/css/main.css" rel="stylesheet" type="text/css">
        <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
        <link rel="shortcut icon" href="/image/Yc.jpg">
        <link href="/css/prism.css" rel="stylesheet" />
        <title>面试题5：从尾到头打印链表</title>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-78070816-3"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            
            gtag('config', 'UA-78070816-3');
        </script>
    </head>
    <body>
        <!-- suppport block of mathjax -->
        <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>
        <!-- support mathjax inline -->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                tex2jax: {inlineMath: [['$','$']]},
                messageStyle: "none"
            });
        </script>
        <script>
            if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)){
                document.body.classList.add('mobile');
            }
        </script>
        <script src="/js/prism.js"></script>
        <div class="inner">
            <h2>面试题5：从尾到头打印链表</h2>

<h3>题目：输入一个链表的头结点，从尾到头反过来打印出每个节点的值。</h3>

<h3>分析</h3>

<p>这道题有如下几种解决方案：</p>

<ol>
<li>将链表逆置，然后顺次打印</li>
<li>递归方案</li>
<li>迭代方案</li>
</ol>

<hr />

<p><strong>如果逆置链表的话，会改变链表原先的结构。我们可以在面试时询问面试过是否可以改变链表，如果是肯定的回答，就可以采用这种办法。否则只能采用后面的方法。</strong></p>

<p><strong>逆置链表也很简单，只需要从第二个节点开始，顺次摘取一个节点头插就可以。</strong></p>

<h3>代码如下</h3>

<pre><code>list* PrintListInReversedOrder(list* &amp;amp;amp;head)
{
    if(head==NULL || head-&amp;amp;gt;next==NULL)
        return head;
    list* tmp=NULL;
    list* cur=head-&amp;amp;gt;next;
    head-&amp;amp;gt;next=NULL;
    while(cur!=NULL)
    {
        tmp=cur-&amp;amp;gt;next;
        cur-&amp;amp;gt;next=head;
        head=cur;
        cur=tmp;
    }
    cur=head;
    while(cur!=NULL)
    {
        cout&amp;amp;lt;&amp;amp;lt;cur-&amp;amp;gt;data&amp;amp;lt;&amp;amp;lt;&amp;amp;quot; &amp;amp;quot;;
        cur=cur-&amp;amp;gt;next;
    }
    cout&amp;amp;lt;&amp;amp;lt;endl;
    return head;
}

````

**递归方案很简单，如果当前函数参数所指向的节点是尾节点，则打印之。否则先打印它的下一个节点即可。**

### 代码如下

````
void PrintListInReversedOrder(list* head)
{
    if(head==NULL)
        return;
    PrintListInReversedOrder(head-&amp;amp;gt;next);
    cout&amp;amp;lt;&amp;amp;lt;head-&amp;amp;gt;data&amp;amp;lt;&amp;amp;lt;&amp;amp;quot; &amp;amp;quot;;
}
````

**但如果链表太长，采用递归的话可能会导致Stack OverFlow，所以更好的办法是用循环来控制。而递归在本质上就是一个栈结构（系统栈），所以我们可以用自定义的栈（数据结构栈）来模拟递归的行为以实现这种效果。**

### 代码如下

````
#include&amp;amp;lt;stack&amp;amp;gt;
void PrintListInReversedOrder(list* head)
{                                                                 //此处不用判断head是否为空，并非忘记
    stack&amp;amp;lt;list*&amp;amp;gt; s;
    list* cur=head;
    while(cur!=NULL)
    {
        s.push(cur);
        cur=cur-&amp;amp;gt;next;
    }
    while(!s.empty())
    {
        cout&amp;amp;lt;&amp;amp;lt;s.top()-&amp;amp;gt;data&amp;amp;lt;&amp;amp;lt;&amp;amp;quot; &amp;amp;quot;;
        s.pop();
    }
}
</code></pre>

<p><strong>以上</strong></p>

<p>如果你有任何想法或是可以改进的地方，欢迎和我交流！</p>

<p>完整代码及测试用例在github上：[点我前往]()</p>

        </div>
    </body>
</html>

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/haoel/anti-baidu@0.6.2/js/anti-baidu-latest.min.js" charset="UTF-8"></script>
